<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: AlphaTeam.Blast Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespace_alpha_team_1_1_blast.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">AlphaTeam.Blast Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a499288aca0f87577a7d3b9b79493d000" id="r_a499288aca0f87577a7d3b9b79493d000"><td class="memItemLeft" align="right" valign="top">pd.DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a499288aca0f87577a7d3b9b79493d000">create_query_df</a> (list kmer_query_list)</td></tr>
<tr class="separator:a499288aca0f87577a7d3b9b79493d000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452a11d85bde784062f483f79e20e4b2" id="r_a452a11d85bde784062f483f79e20e4b2"><td class="memItemLeft" align="right" valign="top">pd.DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a452a11d85bde784062f483f79e20e4b2">fill_df_query</a> (pd.DataFrame df, str nome_colonna)</td></tr>
<tr class="separator:a452a11d85bde784062f483f79e20e4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489f875fe627f835d8a347fb48026724" id="r_a489f875fe627f835d8a347fb48026724"><td class="memItemLeft" align="right" valign="top">pd.DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a489f875fe627f835d8a347fb48026724">create_sub_df</a> (list kmer_sub_list)</td></tr>
<tr class="separator:a489f875fe627f835d8a347fb48026724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f717f0433e8e56f94fcc1c1e24276d9" id="r_a5f717f0433e8e56f94fcc1c1e24276d9"><td class="memItemLeft" align="right" valign="top">pd.DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f717f0433e8e56f94fcc1c1e24276d9">fill_sub_df</a> (pd.DataFrame df, list kmer_subject_list)</td></tr>
<tr class="separator:a5f717f0433e8e56f94fcc1c1e24276d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eec237cc8167008e26f320421c293a4" id="r_a8eec237cc8167008e26f320421c293a4"><td class="memItemLeft" align="right" valign="top">pd.DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8eec237cc8167008e26f320421c293a4">create_df_with_positions</a> (pd.DataFrame query_df, pd.DataFrame subject_df, str filename)</td></tr>
<tr class="separator:a8eec237cc8167008e26f320421c293a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1af01c5322feaa9a13f02c982266f3" id="r_a6d1af01c5322feaa9a13f02c982266f3"><td class="memItemLeft" align="right" valign="top">pd.DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d1af01c5322feaa9a13f02c982266f3">find_seeds</a> (pd.DataFrame df, str filename, int kmer_length=22)</td></tr>
<tr class="separator:a6d1af01c5322feaa9a13f02c982266f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4962b11f3e284d94c46cfcb57b30267" id="r_aa4962b11f3e284d94c46cfcb57b30267"><td class="memItemLeft" align="right" valign="top">str or None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4962b11f3e284d94c46cfcb57b30267">get_sequence</a> (str header, list list_partenza_subject)</td></tr>
<tr class="separator:aa4962b11f3e284d94c46cfcb57b30267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc6c2a636bd37afb9d5fd43f43b4a50" id="r_a7dc6c2a636bd37afb9d5fd43f43b4a50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dc6c2a636bd37afb9d5fd43f43b4a50">calculate_score</a> (str sequence_1, str sequence_2)</td></tr>
<tr class="separator:a7dc6c2a636bd37afb9d5fd43f43b4a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae829cb8bf744e1043fad158eceac4013" id="r_ae829cb8bf744e1043fad158eceac4013"><td class="memItemLeft" align="right" valign="top">tuple[str, str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae829cb8bf744e1043fad158eceac4013">handle_gaps</a> (str finestra_aggiunta_gap_query, str finestra_aggiunta_gap_sub, str finestra_mismatch_query, str finestra_mismatch_sub, int gap_size, str gap_target, int x_max)</td></tr>
<tr class="separator:ae829cb8bf744e1043fad158eceac4013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c320028e060a24fbdc616861572cf3" id="r_aa8c320028e060a24fbdc616861572cf3"><td class="memItemLeft" align="right" valign="top">tuple[int, int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8c320028e060a24fbdc616861572cf3">find_mismatch_window</a> (str sequence_query_ext, str sequence_sub_ext, int x_max)</td></tr>
<tr class="separator:aa8c320028e060a24fbdc616861572cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15327dc117b6fa95b85cd8a6835110c8" id="r_a15327dc117b6fa95b85cd8a6835110c8"><td class="memItemLeft" align="right" valign="top">tuple[str, str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15327dc117b6fa95b85cd8a6835110c8">extend_seed_right</a> (str sequence_query_ext, str sequence_sub_ext, int gap_size, bool perform_gap, str gap_target, int x_max)</td></tr>
<tr class="separator:a15327dc117b6fa95b85cd8a6835110c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d14c9a4e6e88e6b6fdc057f0a03f681" id="r_a1d14c9a4e6e88e6b6fdc057f0a03f681"><td class="memItemLeft" align="right" valign="top">tuple[list, list, list, list]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d14c9a4e6e88e6b6fdc057f0a03f681">extend_seed</a> (pd.DataFrame df_seeds, tuple query_partenza, list list_partenza_subject, int x_max)</td></tr>
<tr class="separator:a1d14c9a4e6e88e6b6fdc057f0a03f681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9b00de9ac817edc5ab991c7c580ce3" id="r_a8a9b00de9ac817edc5ab991c7c580ce3"><td class="memItemLeft" align="right" valign="top">pd.DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a9b00de9ac817edc5ab991c7c580ce3">create_results_table</a> (list cont_hsp_query, list cont_hsp_sub, list cont_hsp_score, list col, str filename)</td></tr>
<tr class="separator:a8a9b00de9ac817edc5ab991c7c580ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b1dfafa0b8b0aa87857bf1cdaf0484" id="r_a34b1dfafa0b8b0aa87857bf1cdaf0484"><td class="memItemLeft" align="right" valign="top">tuple[list, list, list]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34b1dfafa0b8b0aa87857bf1cdaf0484">metrics_for_blast</a> (pd.DataFrame best_alignment_df, tuple query_partenza, list list_partenza_subject)</td></tr>
<tr class="separator:a34b1dfafa0b8b0aa87857bf1cdaf0484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa731dd1718fc10b4cea874b87f54c52" id="r_aaa731dd1718fc10b4cea874b87f54c52"><td class="memItemLeft" align="right" valign="top">pd.DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa731dd1718fc10b4cea874b87f54c52">blast_result_df</a> (pd.DataFrame best_alignment_query, tuple query_partenza, list list_partenza_subject, str filename)</td></tr>
<tr class="separator:aaa731dd1718fc10b4cea874b87f54c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883b22dfa70ab239df4b9a28a18606d9" id="r_a883b22dfa70ab239df4b9a28a18606d9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a883b22dfa70ab239df4b9a28a18606d9">print_alignment</a> (pd.DataFrame best_alignment_df, str output_file, pd.DataFrame result_df)</td></tr>
<tr class="separator:a883b22dfa70ab239df4b9a28a18606d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6c922b4e0d82efb03d3ac4711d63cbca" id="r_a6c922b4e0d82efb03d3ac4711d63cbca"><td class="memItemLeft" align="right" valign="top"><a id="a6c922b4e0d82efb03d3ac4711d63cbca" name="a6c922b4e0d82efb03d3ac4711d63cbca"></a>
dict&#160;</td><td class="memItemRight" valign="bottom"><b>transizione</b> = {'A': 'G', 'G': 'A', 'C': 'T', 'T': 'C'}</td></tr>
<tr class="separator:a6c922b4e0d82efb03d3ac4711d63cbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1378a493295838c500aeb73bdbac36" id="r_a2b1378a493295838c500aeb73bdbac36"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b1378a493295838c500aeb73bdbac36">trasversione</a></td></tr>
<tr class="separator:a2b1378a493295838c500aeb73bdbac36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Modulo Blast

Questo modulo contiene funzioni per eseguire BLAST (Basic Local Alignment Search Tool).
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aaa731dd1718fc10b4cea874b87f54c52" name="aaa731dd1718fc10b4cea874b87f54c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa731dd1718fc10b4cea874b87f54c52">&#9670;&#160;</a></span>blast_result_df()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> pd.DataFrame AlphaTeam.Blast.blast_result_df </td>
          <td>(</td>
          <td class="paramtype">pd.DataFrame</td>          <td class="paramname"><span class="paramname"><em>best_alignment_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple</td>          <td class="paramname"><span class="paramname"><em>query_partenza</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>list_partenza_subject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione migliora un dataframe di allineamento BLAST con le metriche calcolate e le salva in un DataFrame come file .csv.
Parameters
----------
best_alignment_query (pd.DataFrame): dataframe contenente i migliori allineamenti.
query_partenza (tuple): tupla in cui il secondo elemento della query è la sequenza query usata per le analisi del BLAST. 
list_partenza_subject (list): lista di sequenze subject che ritorna la lunghezza delle subject per il calcolo dell’E-value.
filename (str): nome del file nel quale il dataframe verrà salvato.
Return
------
best_alignment_query (pd.DataFrame): dataframe salvato in un file .csv con lo specifico filename.
</pre> 
</div>
</div>
<a id="a7dc6c2a636bd37afb9d5fd43f43b4a50" name="a7dc6c2a636bd37afb9d5fd43f43b4a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc6c2a636bd37afb9d5fd43f43b4a50">&#9670;&#160;</a></span>calculate_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int AlphaTeam.Blast.calculate_score </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>sequence_1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>sequence_2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione calcola il punteggio di somiglianza tra due sequenze in base a regole specifiche di corrispondenza e penalità.
Parameters
----------
 sequence_1 (str): prima sequenza da confrontare.
 sequence_2 (str): seconda sequenza da confrontare.
Return
------
 score (int): punteggio di somiglianza.
</pre> 
</div>
</div>
<a id="a8eec237cc8167008e26f320421c293a4" name="a8eec237cc8167008e26f320421c293a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eec237cc8167008e26f320421c293a4">&#9670;&#160;</a></span>create_df_with_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> pd.DataFrame AlphaTeam.Blast.create_df_with_positions </td>
          <td>(</td>
          <td class="paramtype">pd.DataFrame</td>          <td class="paramname"><span class="paramname"><em>query_df</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pd.DataFrame</td>          <td class="paramname"><span class="paramname"><em>subject_df</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione combina i due dataframe in input, tramite inner join, per generarne uno nuovo contenente posizioni corrispondenti
di k-mer tra i due. Salva poi il risultato in un file CSV e restituisce il dataframe finale.
Parameters
----------
 query_df (pd.DataFrame): dataframe con i k-mers realtivi alla sequenza query e relative posizioni.
 subject_df (pd.DataFrame): dataframe con i k-mers realtivi alle sequenze subject e relative posizioni nella lista.
 filename (str): nome del file (senza estensione) in cui il dataframe risultante verrà salvato in formato .csv.
Return
------
 final_df (pd.DataFrame): dataframe risultante che mappa i k-mer con le posizioni della query e dei subject in tuple,
   salvato anche come file CSV.
</pre> 
</div>
</div>
<a id="a499288aca0f87577a7d3b9b79493d000" name="a499288aca0f87577a7d3b9b79493d000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499288aca0f87577a7d3b9b79493d000">&#9670;&#160;</a></span>create_query_df()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> pd.DataFrame AlphaTeam.Blast.create_query_df </td>
          <td>(</td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>kmer_query_list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione prende una lista di input (kmer_query_list) e costruisce un dataframe Pandas 
organizzato in modo specifico con intestazioni e indici derivati dalla lista. 
Parameters
----------
 kmer_query_list (list): Lista alternata di intestazioni (index pari) e liste di k-mers (index dispari).
Return
------
 df (pd.DataFrame) : dataframe con relativi valori. 
</pre> 
</div>
</div>
<a id="a8a9b00de9ac817edc5ab991c7c580ce3" name="a8a9b00de9ac817edc5ab991c7c580ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9b00de9ac817edc5ab991c7c580ce3">&#9670;&#160;</a></span>create_results_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> pd.DataFrame AlphaTeam.Blast.create_results_table </td>
          <td>(</td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>cont_hsp_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>cont_hsp_sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>cont_hsp_score</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Crea una result table dagli HSP (High-scoring Segment Pair) data e li salva in un file .csv. 
La tabella include query sequence, subject sequences, headers e gli scores, ordinati in modo decrescente. 
Parameters
----------
cont_hsp_query (list): lista delle sequenze query derivate dall'analisi dell'HSP.
cont_hsp_sub (list): lista delle sequenze subject derivate dall'analisi dell'HSP.
cont_hsp_score (list):  lista di score corrispondente agli HSP.
col (list): elenco di headers o identificatori per i risultati HSP.
filename (str):nome del file (senza estensione) nel quale il result-table verrà salvato.
Return
------
results_df (pd.DataFrame): salvato come file .csv.Un pandas DataFrame contenente
  i risultati degli HSP con le colonne 'hsp_query','hsp_sub','header','hsp_score'.
</pre> 
</div>
</div>
<a id="a489f875fe627f835d8a347fb48026724" name="a489f875fe627f835d8a347fb48026724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489f875fe627f835d8a347fb48026724">&#9670;&#160;</a></span>create_sub_df()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> pd.DataFrame AlphaTeam.Blast.create_sub_df </td>
          <td>(</td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>kmer_sub_list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione  costruisce un DataFrame Pandas organizzato in modo specifico con intestazioni e indici derivati dalla lista in input.
In particolare, gli indici sono unici e disposti in ordine alfabetico.
Parameters
----------
kmer_sub_list (list): lista alternata di intestazioni delle sequenze e liste di k-mers relativi ad ogni sequenza.
Return
------
df (pd.DataFrame): dataframe che ha come indici i k-mers unici e in ordine alfabetico e, come nomi delle colonne, le intestazioni delle sequenze subject.
</pre> 
</div>
</div>
<a id="a1d14c9a4e6e88e6b6fdc057f0a03f681" name="a1d14c9a4e6e88e6b6fdc057f0a03f681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d14c9a4e6e88e6b6fdc057f0a03f681">&#9670;&#160;</a></span>extend_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[list,list,list,list] AlphaTeam.Blast.extend_seed </td>
          <td>(</td>
          <td class="paramtype">pd.DataFrame</td>          <td class="paramname"><span class="paramname"><em>df_seeds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple</td>          <td class="paramname"><span class="paramname"><em>query_partenza</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>list_partenza_subject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x_max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estende gli allineamenti dei seed iterando su di essi in un DataFrame fra la sequenza query e le molteplici sequenze subject per produrre degli high-scoring segment pairs (HSPs).  
Gestisce i mismatches, i gaps, e gli allineamenti continui laddove possibile.
Parameters
----------
df_seeds (pd.DataFrame): dataframe contenente i seeds per ogni colonna delle sequenze dei subject. 
query_partenza (tuple): tupla contenente l'header della query e la sua sequenza.
list_partenza_subject (list): lista di tuple, in cui ogni tupla contiene l'header della sequenza subject e la sequenza corrispondente. 
x_max (int): numero massimo di mismatches consecutivi consentito prima dell'arresto dell'estensione dell'allineamento. 
Return
------
tuple[list,list,list,list]: tupla composta da:
-contenitore_hsp_query (list): lista degli allineamenti della query. 
-contenitore_hsp_sub (list): lista degli allineamenti delle subject estese. 
-contenitore_score (list): lista degli scores per ogni allineamento esteso, in cui lo score si basa sulla lunghezza e sui matches.  
-contenitore_ref (list): lista degli header dei subject del corrispettivo allineamento esteso.  
</pre> 
</div>
</div>
<a id="a15327dc117b6fa95b85cd8a6835110c8" name="a15327dc117b6fa95b85cd8a6835110c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15327dc117b6fa95b85cd8a6835110c8">&#9670;&#160;</a></span>extend_seed_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[str,str] AlphaTeam.Blast.extend_seed_right </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>sequence_query_ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>sequence_sub_ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>gap_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform_gap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>gap_target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x_max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estende l'allineamento della query e delle sequenze subject da destra, inserisce i gap quando è necessario.
Parameters
----------
sequence_query_ext (str): sequenza query da estendere.
sequence_sub_ext (str): sequenza subject da estendere.
gap_size (int): numero massimo di gaps consentiti durante l'estensione.  
perform_gap (bool): se True, i gaps sono inseriti per ottimizzare l'allineamento quando i mismatches superano la soglia consentita.
gap_target (str):specifica dove introdurre i gaps: “query” aggiunge i gaps alla sequenza query e “subject” li aggiunge alla sequenza subject. 
x_max (int): threshold per i mismatches consecutivi necessari per attivare l'inserimento dei gaps o fermare l'estensione.  
Return
------
tuple[str,str]: tupla composta da:
-extension_right_query (str): sequenza query estesa. 
-extension_right_sub (str): sequenze subject estese.
</pre> 
</div>
</div>
<a id="a452a11d85bde784062f483f79e20e4b2" name="a452a11d85bde784062f483f79e20e4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452a11d85bde784062f483f79e20e4b2">&#9670;&#160;</a></span>fill_df_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> pd.DataFrame AlphaTeam.Blast.fill_df_query </td>
          <td>(</td>
          <td class="paramtype">pd.DataFrame</td>          <td class="paramname"><span class="paramname"><em>df</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>nome_colonna</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione prende in input un dataframe esistente e aggiunge una nuova colonna e ne riempie le celle. 
Parameters
----------
 df (pd.DataFrame): dataframe di partenza.
 nome_colonna (str): intestazione della nuova colonna. 
Return
------
 df (pd.DataFrame): dataframe aggiornato con la nuova colonna e relativi valori.
</pre> 
</div>
</div>
<a id="a5f717f0433e8e56f94fcc1c1e24276d9" name="a5f717f0433e8e56f94fcc1c1e24276d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f717f0433e8e56f94fcc1c1e24276d9">&#9670;&#160;</a></span>fill_sub_df()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> pd.DataFrame AlphaTeam.Blast.fill_sub_df </td>
          <td>(</td>
          <td class="paramtype">pd.DataFrame</td>          <td class="paramname"><span class="paramname"><em>df</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>kmer_subject_list</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione prende in input un dataframe pre-esistente e ne riempie le celle ricavando informazioni dalla lista in input.
In particolare, essa verifica se ogni K-mer è presente nella lista dei k-mers associata ad ogni colonna e inserisce nelle celle 
l'indice che il k-mer occupa nella lista se esso è presente in quest'ultima.
Parameters
----------
 df (pd.DataFrame): dataframe iniziale
 kmer_subject_list (list): lista alternata di intestazioni delle sequenze e liste di k-mers relativi ad ogni sequenza.
Return
------
 df (pd.DataFrame): dataframe completo di valori.
</pre> 
</div>
</div>
<a id="aa8c320028e060a24fbdc616861572cf3" name="aa8c320028e060a24fbdc616861572cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c320028e060a24fbdc616861572cf3">&#9670;&#160;</a></span>find_mismatch_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[int,int] AlphaTeam.Blast.find_mismatch_window </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>sequence_query_ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>sequence_sub_ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x_max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione confronta le basi nelle stesse posizioni delle sequenze in input assegnando un punteggio positivo ad ogni match.
Ogni mismatch consecutivo incrementa un contatore. Se il numero di mismatch consecutivi raggiunge il valore soglia,
il ciclo si interrompe.
Parameters
----------
 sequence_query_ext (str): sequenza estesa da query da confrontare.
 seqeunce_sub_ext (str): sequenza estesa da subject da confrontare.
 x_max (int): numero massimo di mismatch consecutivi consentiti prima di interrompere il confronto.
Return
------
tuple[int,int]: tupla composta da:
 -last_valid_index (int): indice dell'ultima posizione valida prima dei mismatch consecutivi
 -mismatch_consecutivi (int): numero di mismatch consecutiviv rilevati.
</pre> 
</div>
</div>
<a id="a6d1af01c5322feaa9a13f02c982266f3" name="a6d1af01c5322feaa9a13f02c982266f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1af01c5322feaa9a13f02c982266f3">&#9670;&#160;</a></span>find_seeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> pd.DataFrame AlphaTeam.Blast.find_seeds </td>
          <td>(</td>
          <td class="paramtype">pd.DataFrame</td>          <td class="paramname"><span class="paramname"><em>df</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>kmer_length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">22</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione identifica regioni di interesse ("seeds") basandosi sulle tuple (query_start, subject_start) e sul valore kmer_length.
Processa un dataframe contenente tuple rappresentanti posizioni iniziali di k-mer per creare un nuovo dataframe con "seeds"
che includono le posizioni iniziali e finali. I risultati vengono salvati in un file CSV.
Parameters
----------
 df (pd.DataFrame): dataframe con informazioni realtive alle posizioni dei k-mers in seqeunze query e subject.
 filename (str): nome del file (senza estensione) in cui il dataframe risultante verrà salvato in formato .csv.
 kmer_length (int): lunghezza dei k-mers.
Return
------
 new_df (pd.DataFrame): dataframe con i seeds organizzati, dove ogni seed include posizioni iniziali e finali. 
    I risultati sono salvati anche nel file CSV specificato.
</pre> 
</div>
</div>
<a id="aa4962b11f3e284d94c46cfcb57b30267" name="aa4962b11f3e284d94c46cfcb57b30267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4962b11f3e284d94c46cfcb57b30267">&#9670;&#160;</a></span>get_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str or None  AlphaTeam.Blast.get_sequence </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>list_partenza_subject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Recupera la sequenza corrispondente a un dato header.
Parameters
----------
 header (str): header del subject.
 list_partenza_subject (list): lista di tuple, ogni tupla composta da header e sequenza associata.
Return
------
str o None 
-item[1] (str): se trova corrispondenza
-None se non trova niente.
</pre> 
</div>
</div>
<a id="ae829cb8bf744e1043fad158eceac4013" name="ae829cb8bf744e1043fad158eceac4013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae829cb8bf744e1043fad158eceac4013">&#9670;&#160;</a></span>handle_gaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[str, str] AlphaTeam.Blast.handle_gaps </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>finestra_aggiunta_gap_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>finestra_aggiunta_gap_sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>finestra_mismatch_query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>finestra_mismatch_sub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>gap_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>gap_target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x_max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione gestisce i gap aggiungendoli nella sequenza individuata da gap_target.
Parameters
----------
 finestra_aggiunta_gap_query (str):  sequenza della query dove aggiungere i gap.
 finestra_aggiunta_gap_sub (str): sequenza della subject dove aggiungere i gap.
 finestra_mismatch_query (str): finestra della query che presenta mismatch.
 finestra_mismatch_sub (str): finestra della subject che presenta mismatch.
 gap_size (int): numero massimo di gap consentiti durante l'estensione
 gap_target (str): specifica dove aggiungere i gap. Può essere 'query' o 'subject'.
 x_max (int) : valore massimo negativo del punteggio accettabile per le sequenze.
Return
------
tuple[str,str]: tupla composta da:
 -finestra_aggiunta_gap_query (str): finestra di sequenza query con aggiunta dei gap, o '*' se i gap non migliorano il punteggio.
 -finestra_aggiunta_gap_sub (str): finestra di sequenza subject con aggiunta dei gap, o '*' se i gap non migliorano il punteggio.
</pre> 
</div>
</div>
<a id="a34b1dfafa0b8b0aa87857bf1cdaf0484" name="a34b1dfafa0b8b0aa87857bf1cdaf0484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b1dfafa0b8b0aa87857bf1cdaf0484">&#9670;&#160;</a></span>metrics_for_blast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[list,list,list] AlphaTeam.Blast.metrics_for_blast </td>
          <td>(</td>
          <td class="paramtype">pd.DataFrame</td>          <td class="paramname"><span class="paramname"><em>best_alignment_df</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple</td>          <td class="paramname"><span class="paramname"><em>query_partenza</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list</td>          <td class="paramname"><span class="paramname"><em>list_partenza_subject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione calcola le metriche degli allineamenti del BLAST, includendo query_coverage, E-value e la percentuale di identità. 
Parameters
----------
best_alignment_df (pd.Dataframe): dataframe contenente gli allineamenti migliori.  
query_partenza (tuple): tupla in cui il secondo elemento è una sequenza query usata per le analisi del BLAST.  
list_partenza_subject (list): lista di sequenze subject che recupera la lunghezza dei subject per il calcolo dell' E-value. 
Return
------
tuple[list,list,list]: tupla composta da:
-query_cov_list (list): lista della copertura in percentuale della query per ogni allineamento.
-e_value_list (list): lista degli E-values calcolato per ogni allineamento.
-identity_list (list): lista dei valori in percentuale dell'identità per ogni allineamento.
</pre> 
</div>
</div>
<a id="a883b22dfa70ab239df4b9a28a18606d9" name="a883b22dfa70ab239df4b9a28a18606d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883b22dfa70ab239df4b9a28a18606d9">&#9670;&#160;</a></span>print_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None AlphaTeam.Blast.print_alignment </td>
          <td>(</td>
          <td class="paramtype">pd.DataFrame</td>          <td class="paramname"><span class="paramname"><em>best_alignment_df</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>output_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pd.DataFrame</td>          <td class="paramname"><span class="paramname"><em>result_df</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">La funzione rappresenta i risultati degli allineamenti in un file, includendo l'allineamento di sequenza, le metriche e le annotazioni.
Parameters
----------
best_alignment_df (pd.DataFrame): dataframe contenente i migliori allineamenti in cui nelle colonne inseriamo le query e le sequenze delle subject.
output_file (str): percorso del file di output in cui verranno scritti i risultati dell'allineamento formattato.
result_df (pd.DataFrame): dataframe contenente le metriche calcolate per ogni allineamento
Return
------
None
    Scrive i dettagli dell'allineamento nello specifico output finale.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2b1378a493295838c500aeb73bdbac36" name="a2b1378a493295838c500aeb73bdbac36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1378a493295838c500aeb73bdbac36">&#9670;&#160;</a></span>trasversione</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict AlphaTeam.Blast.trasversione</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&#39;A&#39;</span>: [<span class="stringliteral">&#39;C&#39;</span>, <span class="stringliteral">&#39;T&#39;</span>],</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&#39;C&#39;</span>: [<span class="stringliteral">&#39;A&#39;</span>, <span class="stringliteral">&#39;G&#39;</span>],</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&#39;G&#39;</span>: [<span class="stringliteral">&#39;C&#39;</span>, <span class="stringliteral">&#39;T&#39;</span>],</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&#39;T&#39;</span>: [<span class="stringliteral">&#39;A&#39;</span>, <span class="stringliteral">&#39;G&#39;</span>]</div>
<div class="line"><span class="lineno">    6</span>}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>AlphaTeam</b></li><li class="navelem"><a class="el" href="namespace_alpha_team_1_1_blast.html">Blast</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
